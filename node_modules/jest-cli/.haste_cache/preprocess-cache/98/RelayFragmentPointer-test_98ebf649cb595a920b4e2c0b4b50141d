/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @emails oncall+relay
 */

'use strict';var _extends = Object.assign || function (target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i];for (var key in source) {if (Object.prototype.hasOwnProperty.call(source, key)) {target[key] = source[key];}}}return target;};

require('configureForRelayOSS');

jest.dontMock('RelayFragmentPointer');






describe('RelayFragmentPointer', function () {var 
  getNode = require('RelayTestUtils').getNode;var getRefNode = require('RelayTestUtils').getRefNode;

  beforeEach(function () {
    jest.resetModuleRegistry();

    jasmine.addMatchers(require('RelayTestUtils').matchers);
    jasmine.addMatchers({ 
      toEqualPointer: function () {
        return { 
          compare: function (actual, expected) {
            return { 
              pass: actual.equals(expected) };} };} });});







  describe('createForRoot', function () {
    var recordStore;

    beforeEach(function () {
      var records = {};
      recordStore = new (require('RelayRecordStore'))({ records: records });});


    it('creates a wrapped fragment pointer', function () {
      var rootFragment = (function () {return { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], kind: 'Fragment', metadata: { isAbstract: true }, name: 'RelayFragmentPointerRelayQL', type: 'Node' };})();
      var root = getNode((function (RQL_0) {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '123' } }], children: [].concat.apply([], [{ fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }, require('Relay').QL.__frag(RQL_0)]), fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'RelayFragmentPointer', type: 'Node' };})(rootFragment));

      var result = require('RelayFragmentPointer').createForRoot(recordStore, root);
      var resultKeys = Object.keys(result);
      expect(resultKeys.length).toBe(1);

      var fragmentPointer = result[resultKeys[0]];
      expect(fragmentPointer.getDataID()).toBe('123');
      expect(fragmentPointer.getFragment()).toEqualQueryNode(
      getNode(rootFragment));});



    it('throws if multiple root fragments are present', function () {
      var rootFragmentA = (function () {return { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], kind: 'Fragment', metadata: { isAbstract: true }, name: 'RelayFragmentPointerRelayQL', type: 'Node' };})();
      var rootFragmentB = (function () {return { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], kind: 'Fragment', metadata: { isAbstract: true }, name: 'RelayFragmentPointerRelayQL', type: 'Node' };})();
      var root = getNode((function (RQL_0, RQL_1) {return { calls: [{ kind: 'Call', metadata: {}, name: 'name', value: { kind: 'CallValue', callValue: 'foo' } }], children: [].concat.apply([], [{ fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }, require('Relay').QL.__frag(RQL_0), require('Relay').QL.__frag(RQL_1)]), fieldName: 'username', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'name' }, name: 'RelayFragmentPointer', type: 'Actor' };})(

      rootFragmentA, rootFragmentB));



      expect(function () {
        require('RelayFragmentPointer').createForRoot(recordStore, root);}).
      toFailInvariant(
      'Queries supplied at the root should contain exactly one fragment ' + 
      '(e.g. `${Component.getFragment(\'...\')}`). Query ' + 
      '`RelayFragmentPointer` contains more than one fragment.');});



    it('throws if non-fragments are present', function () {
      var root = getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'name', value: { kind: 'CallValue', callValue: 'foo' } }], children: [{ fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'username', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'name' }, name: 'RelayFragmentPointer', type: 'Actor' };})());

      expect(function () {
        require('RelayFragmentPointer').createForRoot(recordStore, root);}).
      toFailInvariant(
      'Queries supplied at the root should contain exactly one fragment ' + 
      'and no fields. Query `RelayFragmentPointer` contains a field, ' + 
      '`name`. If you need to fetch fields, declare them in a Relay ' + 
      'container.');});



    it('throws for unknown ref queries', function () {
      var rootFragment = (function () {return { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], kind: 'Fragment', metadata: { isAbstract: true }, name: 'RelayFragmentPointerRelayQL', type: 'Node' };})();
      var root = getRefNode((function (RQL_0) {return { calls: [{ kind: 'Call', metadata: {}, name: 'ids', value: { kind: 'CallVariable', callVariableName: 'ref_q0' } }], children: [].concat.apply([], [{ fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }, require('Relay').QL.__frag(RQL_0)]), fieldName: 'nodes', kind: 'Query', metadata: { isPlural: true, isAbstract: true, identifyingArgName: 'ids' }, name: 'RelayFragmentPointer', type: 'Node' };})(
      rootFragment), 
      { path: '$.*.id' });


      expect(function () {
        require('RelayFragmentPointer').createForRoot(recordStore, root);}).
      toFailInvariant(
      'Queries supplied at the root cannot have batch call variables. ' + 
      'Query `RelayFragmentPointer` has a batch call variable, `ref_q0`.');});



    it('returns null when the root call was not fetched', function () {
      // When a root call is not fetched since it only contained empty
      // fragments, we shouldn't throw.
      var ref = (function () {return { children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'actor', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isAbstract: true }, type: 'Actor' }], kind: 'Fragment', metadata: {}, name: 'RelayFragmentPointerRelayQL', type: 'Viewer' };})();
      var root = getNode((function (RQL_0) {return { children: [].concat.apply([], [require('Relay').QL.__frag(RQL_0)]), fieldName: 'viewer', kind: 'Query', metadata: {}, name: 'RelayFragmentPointer', type: 'Viewer' };})(ref));

      expect(
      require('RelayFragmentPointer').createForRoot(recordStore, root)).
      toBeNull();});});



  describe('plurality', function () {
    var variables;
    var singular;
    var singularFragment;
    var plural;
    var pluralFragment;

    beforeEach(function () {
      variables = { a: true, b: 1, c: '' };
      singular = (function () {return { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], kind: 'Fragment', metadata: { isAbstract: true }, name: 'RelayFragmentPointerRelayQL', type: 'Node' };})();
      singularFragment = getNode(singular, variables);
      plural = (function () {return { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], kind: 'Fragment', metadata: { plural: true, isAbstract: true }, name: 'RelayFragmentPointerRelayQL', type: 'Node' };})();
      pluralFragment = getNode(plural, variables);});


    it('creates singular pointers', function () {
      var pointer = new (require('RelayFragmentPointer'))('123', singularFragment);

      expect(pointer.getDataID()).toBe('123');
      expect(pointer.getFragment()).toBe(singularFragment);
      expect(pointer.equals(pointer)).toBeTruthy();
      expect(function () {return pointer.getDataIDs();}).toFailInvariant(
      'RelayFragmentPointer.getDataIDs(): Bad call for non-plural fragment.');});



    it('creates plural pointers', function () {
      var pointer = new (require('RelayFragmentPointer'))(['123'], pluralFragment);

      expect(pointer.getDataIDs()).toEqual(['123']);
      expect(pointer.getFragment()).toBe(pluralFragment);
      expect(pointer.equals(pointer)).toBeTruthy();
      expect(function () {return pointer.getDataID();}).toFailInvariant(
      'RelayFragmentPointer.getDataID(): Bad call for plural fragment.');});



    /* eslint-disable no-new */
    it('throws when creating a singular pointer with multiple IDs', function () {
      expect(function () {
        new (require('RelayFragmentPointer'))(['123'], singularFragment);}).
      toFailInvariant(
      'RelayFragmentPointer: Wrong plurality, array of data IDs ' + 
      'supplied with non-plural fragment.');});



    it('throws when creating a plural pointer with a single ID', function () {
      expect(function () {
        new (require('RelayFragmentPointer'))('123', pluralFragment);}).
      toFailInvariant(
      'RelayFragmentPointer: Wrong plurality, single data ID supplied ' + 
      'with plural fragment.');});


    /* eslint-enable no-new */

    it('singular pointers are equals() to matching pointers', function () {
      var pointer = new (require('RelayFragmentPointer'))('123', singularFragment);
      var another = 
      new (require('RelayFragmentPointer'))('123', getNode(singular, variables));

      expect(pointer).toEqualPointer(another);});


    it('singular pointers are not equals() to different pointers', function () {
      var pointer = new (require('RelayFragmentPointer'))('123', singularFragment);
      // different id
      expect(pointer).not.toEqualPointer(
      new (require('RelayFragmentPointer'))('456', getNode(singular, variables)));

      // different fragment
      expect(pointer).not.toEqualPointer(
      new (require('RelayFragmentPointer'))(
      '123', 
      getNode((function () {return { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], kind: 'Fragment', metadata: { isAbstract: true }, name: 'RelayFragmentPointerRelayQL', type: 'Node' };})(), variables)));


      // different variables
      var differentVariables = _extends({}, variables, { d: 'different' });
      expect(pointer).not.toEqualPointer(
      new (require('RelayFragmentPointer'))('123', getNode(singular, differentVariables)));});



    it('plural pointers are equals() to matching pointers', function () {
      var pointer = new (require('RelayFragmentPointer'))(['123'], pluralFragment);
      var another = new (require('RelayFragmentPointer'))(
      ['123'], 
      getNode(plural, variables));


      expect(pointer).toEqualPointer(another);});


    it('plural pointers are not equals() to different pointers', function () {
      var pointer = new (require('RelayFragmentPointer'))(['123'], pluralFragment);
      // different id
      expect(pointer).not.toEqualPointer(
      new (require('RelayFragmentPointer'))(['456'], getNode(plural, variables)));

      expect(pointer).not.toEqualPointer(
      new (require('RelayFragmentPointer'))(['123', '456'], getNode(plural, variables)));

      // different fragment
      expect(pointer).not.toEqualPointer(
      new (require('RelayFragmentPointer'))(
      ['123'], 
      getNode((function () {return { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], kind: 'Fragment', metadata: { plural: true, isAbstract: true }, name: 'RelayFragmentPointerRelayQL', type: 'Node' };})(), variables)));


      // different variables
      var differentVariables = _extends({}, variables, { d: 'different' });
      expect(pointer).not.toEqualPointer(
      new (require('RelayFragmentPointer'))(['123'], getNode(plural, differentVariables)));});});});