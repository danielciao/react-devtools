/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @emails oncall+relay
 */

'use strict';function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}

require('configureForRelayOSS');

jest.
dontMock('GraphQLRange').
dontMock('GraphQLSegment').
dontMock('GraphQLStoreQueryResolver');










describe('GraphQLStoreQueryResolver', function () {
  var changeEmitter;
  var storeData;

  var mockCallback;
  var mockQueryFragment;
  var mockPluralQueryFragment;var 

  getNode = require('RelayTestUtils').getNode;

  function mockReader(mockResult) {
    require('readRelayQueryData').mockImplementation(function (_, __, dataID) {
      return { 
        dataIDs: _defineProperty({}, dataID, true), 
        data: mockResult[dataID] };});}




  beforeEach(function () {
    jest.resetModuleRegistry();

    storeData = new (require('RelayStoreData'))();
    changeEmitter = storeData.getChangeEmitter();

    mockCallback = jest.genMockFunction();
    mockQueryFragment = getNode((function () {return { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], kind: 'Fragment', metadata: { isAbstract: true }, name: 'GraphQLStoreQueryResolverRelayQL', type: 'Node' };})());
    mockPluralQueryFragment = getNode((function () {return { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], kind: 'Fragment', metadata: { plural: true, isAbstract: true }, name: 'GraphQLStoreQueryResolverRelayQL', type: 'Node' };})());






    jasmine.addMatchers(require('RelayTestUtils').matchers);});


  it('should resolve a pointer', function () {
    var fragmentPointer = new (require('RelayFragmentPointer'))(
    '1038750002', 
    mockQueryFragment);

    var mockResult = { __dataID__: '1038750002', id: '1038750002', name: 'Tim' };
    require('readRelayQueryData').mockReturnValue({ data: mockResult });

    var resolver = new (require('GraphQLStoreQueryResolver'))(
    storeData, 
    fragmentPointer, 
    mockCallback);

    var resolved = resolver.resolve(fragmentPointer);

    expect(resolved).toBe(mockResult);

    expect(require('readRelayQueryData')).toBeCalled();
    expect(require('readRelayQueryData').mock.calls[0][1]).toBe(mockQueryFragment);
    expect(require('readRelayQueryData').mock.calls[0][2]).toEqual(
    fragmentPointer.getDataID());});



  it('should subscribe to IDs in resolved pointer', function () {
    var fragmentPointer = new (require('RelayFragmentPointer'))(
    '1038750002', 
    mockQueryFragment);

    var mockResult = { 
      '1038750002': { __dataID__: '1038750002', id: '1038750002', name: 'Tim' } };

    mockReader(mockResult);

    var resolver = new (require('GraphQLStoreQueryResolver'))(
    storeData, 
    fragmentPointer, 
    mockCallback);

    resolver.resolve(fragmentPointer);

    var addListenersForIDs = changeEmitter.addListenerForIDs;
    expect(addListenersForIDs).toBeCalled();
    expect(addListenersForIDs.mock.calls[0][0]).toEqual(['1038750002']);});


  it('should not re-resolve pointers without change events', function () {
    var fragmentPointer = new (require('RelayFragmentPointer'))(
    '1038750002', 
    mockQueryFragment);

    var mockResultA = { __dataID__: '1038750002', id: '1038750002', name: 'Tim' };
    var mockResultB = { __dataID__: '1038750002', id: '1038750002', name: 'Tim' };

    var resolver = new (require('GraphQLStoreQueryResolver'))(
    storeData, 
    fragmentPointer, 
    mockCallback);


    require('readRelayQueryData').mockReturnValue({ data: mockResultA });
    var resolvedA = resolver.resolve(fragmentPointer);

    require('readRelayQueryData').mockReturnValue({ data: mockResultB });
    var resolvedB = resolver.resolve(fragmentPointer);

    expect(require('readRelayQueryData').mock.calls.length).toBe(1);
    expect(resolvedA).toBe(resolvedB);});


  it('should re-resolve pointers with change events', function () {
    var fragmentPointer = new (require('RelayFragmentPointer'))(
    '1038750002', 
    mockQueryFragment);

    var mockResultA = { __dataID__: '1038750002', id: '1038750002', name: 'Tim' };
    var mockResultB = { __dataID__: '1038750002', id: '1038750002', name: 'Tee' };

    var resolver = new (require('GraphQLStoreQueryResolver'))(
    storeData, 
    fragmentPointer, 
    mockCallback);


    mockReader(_defineProperty({}, 
    mockResultA.id, mockResultA));

    var resolvedA = resolver.resolve(fragmentPointer);

    var callback = changeEmitter.addListenerForIDs.mock.calls[0][1];
    callback(['1038750002']);

    mockReader(_defineProperty({}, 
    mockResultB.id, mockResultB));

    var resolvedB = resolver.resolve(fragmentPointer);

    expect(require('readRelayQueryData').mock.calls.length).toBe(2);
    expect(resolvedA).toBe(mockResultA);
    expect(resolvedB).toBe(mockResultB);});


  it('should re-resolve pointers whose calls differ', function () {
    var fragmentPointerA = new (require('RelayFragmentPointer'))(
    'client:123_first(10)', 
    mockQueryFragment);

    var fragmentPointerB = new (require('RelayFragmentPointer'))(
    'client:123_first(20)', 
    mockQueryFragment);


    var resolver = new (require('GraphQLStoreQueryResolver'))(
    storeData, 
    fragmentPointerA, 
    mockCallback);


    require('GraphQLStoreRangeUtils').getCanonicalClientID = 
    // The canonical ID of a range customarily excludes the calls
    jest.genMockFunction().mockReturnValue('client:123');

    resolver.resolve(fragmentPointerA);
    resolver.resolve(fragmentPointerB);

    expect(require('readRelayQueryData').mock.calls.length).toBe(2);});


  it('should invoke the callback when change events fire', function () {
    var fragmentPointer = new (require('RelayFragmentPointer'))(
    '1038750002', 
    mockQueryFragment);

    var mockResult = { 
      '1038750002': { __dataID__: '1038750002', id: '1038750002', name: 'Tim' } };


    var resolver = new (require('GraphQLStoreQueryResolver'))(
    storeData, 
    fragmentPointer, 
    mockCallback);


    mockReader(mockResult);
    resolver.resolve(fragmentPointer);

    var callback = changeEmitter.addListenerForIDs.mock.calls[0][1];
    callback(['1038750002']);

    expect(mockCallback).toBeCalled();});


  it('should resolve an array of pointers', function () {
    var fragmentPointer = new (require('RelayFragmentPointer'))(
    ['1', '2'], 
    mockPluralQueryFragment);

    var mockResults = { 
      '1': { __dataID__: '1', name: 'One' }, 
      '2': { __dataID__: '2', name: 'Two' } };

    mockReader(mockResults);

    var resolver = new (require('GraphQLStoreQueryResolver'))(
    storeData, 
    fragmentPointer, 
    mockCallback);


    var resolved = resolver.resolve(fragmentPointer);
    expect(resolved.length).toBe(2);
    expect(resolved[0]).toBe(mockResults['1']);
    expect(resolved[1]).toBe(mockResults['2']);

    expect(require('readRelayQueryData').mock.calls[0][2]).toEqual(
    fragmentPointer.getDataIDs()[0]);

    expect(require('readRelayQueryData').mock.calls[1][2]).toEqual(
    fragmentPointer.getDataIDs()[1]);});



  it('should not re-resolve if the pointer array has no changes', function () {
    var fragmentPointer = new (require('RelayFragmentPointer'))(
    ['1', '2'], 
    mockPluralQueryFragment);

    var mockResults = { 
      '1': { __dataID__: '1', name: 'One' }, 
      '2': { __dataID__: '2', name: 'Two' } };

    mockReader(mockResults);

    var resolver = new (require('GraphQLStoreQueryResolver'))(
    storeData, 
    fragmentPointer, 
    mockCallback);


    var resolvedA = resolver.resolve(fragmentPointer);
    var resolvedB = resolver.resolve(fragmentPointer);

    expect(resolvedA).toBe(resolvedB);});


  it('should only re-resolve pointers with changes in an array', function () {
    var fragmentPointer = new (require('RelayFragmentPointer'))(
    ['1', '2'], 
    mockPluralQueryFragment);

    var mockResults = { 
      '1': { __dataID__: '1', name: 'One' }, 
      '2': { __dataID__: '2', name: 'Two' } };

    mockReader(mockResults);

    var resolver = new (require('GraphQLStoreQueryResolver'))(
    storeData, 
    fragmentPointer, 
    mockCallback);


    var resolvedA = resolver.resolve(fragmentPointer);

    mockResults['1'] = { __dataID__: '1', name: 'Won' };
    var callback = changeEmitter.addListenerForIDs.mock.calls[0][1];
    callback(['1']);

    var resolvedB = resolver.resolve(fragmentPointer);

    expect(resolvedA).not.toBe(resolvedB);

    expect(resolvedB.length).toBe(2);
    expect(resolvedB[0]).toBe(mockResults['1']);
    expect(resolvedB[1]).toBe(mockResults['2']);

    expect(require('readRelayQueryData').mock.calls.length).toBe(3);
    expect(require('readRelayQueryData').mock.calls[2][2]).toEqual('1');});


  it('should create a new array if the pointer array shortens', function () {
    var fragmentPointer = new (require('RelayFragmentPointer'))(
    ['1', '2'], 
    mockPluralQueryFragment);

    var fragmentPointerB = new (require('RelayFragmentPointer'))(
    ['1'], 
    mockPluralQueryFragment);

    var mockResults = { 
      '1': { __dataID__: '1', name: 'One' }, 
      '2': { __dataID__: '2', name: 'Two' } };

    mockReader(mockResults);

    var resolver = new (require('GraphQLStoreQueryResolver'))(
    storeData, 
    fragmentPointer, 
    mockCallback);


    var resolvedA = resolver.resolve(fragmentPointer);
    var resolvedB = resolver.resolve(fragmentPointerB);

    expect(resolvedA).not.toBe(resolvedB);

    expect(resolvedA.length).toBe(2);
    expect(resolvedB.length).toBe(1);});


  describe('garbage collection', function () {
    var fragment = undefined;

    beforeEach(function () {
      storeData.initializeGarbageCollector(function (run) {
        while (run()) {}});

      var containerFragment = require('RelayTestUtils').createContainerFragment((function () {return { children: [{ children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Field', metadata: { canHaveSubselections: true, isAbstract: true, isRequisite: true }, type: 'FeedUnit' }, { fieldName: 'cursor', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'edges', kind: 'Field', metadata: { canHaveSubselections: true, isPlural: true }, type: 'NewsFeedEdge' }, { children: [{ fieldName: 'hasNextPage', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'Boolean' }, { fieldName: 'hasPreviousPage', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'Boolean' }], fieldName: 'pageInfo', kind: 'Field', metadata: { canHaveSubselections: true, isGenerated: true, isRequisite: true }, type: 'PageInfo' }], kind: 'Fragment', metadata: {}, name: 'GraphQLStoreQueryResolverRelayQL', type: 'NewsFeedConnection' };})());








      fragment = (function (RQL_0) {return { children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'actor', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isAbstract: true }, type: 'Actor' }, { calls: [{ kind: 'Call', metadata: {}, name: 'first', value: { kind: 'CallValue', callValue: '1' } }], children: [].concat.apply([], [require('Relay').QL.__frag(RQL_0)]), fieldName: 'newsFeed', kind: 'Field', metadata: { canHaveSubselections: true, isConnection: true, isFindable: true }, type: 'NewsFeedConnection' }], kind: 'Fragment', metadata: {}, name: 'GraphQLStoreQueryResolverRelayQL', type: 'Viewer' };})(





      containerFragment);



      var query = getNode((function (RQL_0) {return { children: [].concat.apply([], [require('Relay').QL.__frag(RQL_0)]), fieldName: 'viewer', kind: 'Query', metadata: {}, name: 'GraphQLStoreQueryResolver', type: 'Viewer' };})(


      fragment));



      var payload = { 
        viewer: { 
          actor: { 
            id: '123' }, 

          newsFeed: { 
            edges: [
            { 
              node: { 
                id: '456' } }] } } };






      storeData.handleQueryPayload(
      query, 
      require('transformRelayQueryPayload')(query, payload), 
      1);});



    it('increments references to read data', function () {
      var fragmentPointer = new (require('RelayFragmentPointer'))(
      'client:1', 
      getNode(fragment));

      var queryResolver = new (require('GraphQLStoreQueryResolver'))(
      storeData, 
      fragmentPointer, 
      jest.genMockFunction());

      // read data and set up subscriptions
      queryResolver.resolve(fragmentPointer);
      // evict unreferenced nodes
      storeData.getGarbageCollector().collect();
      jest.runAllTimers();
      // nodes referenced by the fragment should not be evicted
      expect(Object.keys(storeData.getNodeData())).toEqual([
      '123', // viewer.actor
      'client:1', // viewer
      'client:2']);}); // viewer.newsFeed



    it('decrements references to previously read fields', function () {
      var fragmentPointer = new (require('RelayFragmentPointer'))(
      'client:1', 
      getNode(fragment));

      var queryResolver = new (require('GraphQLStoreQueryResolver'))(
      storeData, 
      fragmentPointer, 
      jest.genMockFunction());

      // read data and increment GC ref counts
      queryResolver.resolve(fragmentPointer);
      var callback = 
      storeData.getChangeEmitter().addListenerForIDs.mock.calls[0][1];

      // Remove the link to viewer.actor and broadcast an update
      storeData.getRecordWriter().putField('client:1', 'actor', null);
      storeData.getRecordWriter().putField('client:1', 'newsFeed', null);
      callback(['client:1']);

      // re-read and increment/decrement GC ref counts
      queryResolver.resolve(fragmentPointer);

      // evict unreferenced nodes
      storeData.getGarbageCollector().collect();
      jest.runAllTimers();
      // nodes referenced by the fragment should not be evicted
      expect(Object.keys(storeData.getNodeData())).toEqual([
      // '123' (actor) is unreferenced and collected
      // 'client:2' (viewer.newsFeed) is unreferenced and collected
      'client:1']);}); // viewer



    it('decrements references when disposed', function () {
      var fragmentPointer = new (require('RelayFragmentPointer'))(
      'client:1', 
      getNode(fragment));

      var queryResolver = new (require('GraphQLStoreQueryResolver'))(
      storeData, 
      fragmentPointer, 
      jest.genMockFunction());

      // read data and increment GC ref counts
      queryResolver.resolve(fragmentPointer);
      // reset the resolver; should unreference all nodes
      queryResolver.dispose();

      // evict unreferenced nodes
      storeData.getGarbageCollector().collect();
      jest.runAllTimers();
      // all nodes are unreferenced and should be removed
      expect(storeData.getNodeData()).toEqual({});});});});