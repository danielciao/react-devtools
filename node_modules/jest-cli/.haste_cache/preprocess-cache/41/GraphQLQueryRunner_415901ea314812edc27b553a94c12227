/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule GraphQLQueryRunner
 * @typechecks
 * 
 */

'use strict';function _toConsumableArray(arr) {if (Array.isArray(arr)) {for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];return arr2;} else {return Array.from(arr);}}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError('Cannot call a class as a function');}}





































/**
 * This is the high-level entry point for sending queries to the GraphQL
 * endpoint. It provides methods for scheduling queries (`run`), force-fetching
 * queries (ie. ignoring the cache; `forceFetch`).
 *
 * In order to send minimal queries and avoid re-retrieving data,
 * `GraphQLQueryRunner` maintains a registry of pending (in-flight) queries, and
 * "subtracts" those from any new queries that callers enqueue.
 *
 * @internal
 */var 
GraphQLQueryRunner = (function () {


  function GraphQLQueryRunner(storeData) {_classCallCheck(this, GraphQLQueryRunner);
    this._storeData = storeData;}


  /**
   * Fetches data required to resolve a set of queries. See the `RelayStore`
   * module for documentation on the callback.
   */GraphQLQueryRunner.prototype.
  run = function run(
  querySet, 
  callback, 
  fetchMode) 
  {var _this = this;
    fetchMode = fetchMode || require('RelayFetchMode').CLIENT;
    var profiler = fetchMode === require('RelayFetchMode').REFETCH ? 
    require('RelayProfiler').profile('GraphQLQueryRunner.forceFetch') : 
    require('RelayProfiler').profile('GraphQLQueryRunner.primeCache');

    var diffQueries = [];
    if (fetchMode === require('RelayFetchMode').CLIENT) {
      require('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/fbjs/lib/forEachObject')(querySet, function (query) {
        if (query) {
          diffQueries.push.apply(diffQueries, _toConsumableArray(require('diffRelayQuery')(
          query, 
          _this._storeData.getRecordStore(), 
          _this._storeData.getQueryTracker())));}});} else 



    {
      require('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/fbjs/lib/forEachObject')(querySet, function (query) {
        if (query) {
          diffQueries.push(query);}});}




    return runQueries(
    this._storeData, 
    diffQueries, 
    callback, 
    fetchMode, 
    profiler);};



  /**
   * Ignores the cache and fetches data required to resolve a set of queries.
   * Uses the data we get back from the server to overwrite data in the cache.
   *
   * Even though we're ignoring the cache, we will still invoke the callback
   * immediately with `ready: true` if `querySet` can be resolved by the cache.
   */GraphQLQueryRunner.prototype.
  forceFetch = function forceFetch(
  querySet, 
  callback) 
  {
    var fetchMode = require('RelayFetchMode').REFETCH;
    var profiler = require('RelayProfiler').profile('GraphQLQueryRunner.forceFetch');
    var queries = [];
    require('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/fbjs/lib/forEachObject')(querySet, function (query) {
      query && queries.push(query);});


    return runQueries(this._storeData, queries, callback, fetchMode, profiler);};return GraphQLQueryRunner;})();



function hasItems(map) {
  return !!Object.keys(map).length;}


function splitAndFlattenQueries(
queries) 
{
  if (!require('RelayNetworkLayer').supports('defer')) {
    if (__DEV__) {
      queries.forEach(function (query) {
        require('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/fbjs/lib/warning')(
        !query.hasDeferredDescendant(), 
        'Relay: Query `%s` contains a deferred fragment (e.g. ' + 
        '`getFragment(\'foo\').defer()`) which is not supported by the ' + 
        'default network layer. This query will be sent without deferral.', 
        query.getName());});}



    return queries;}


  var flattenedQueries = [];
  queries.forEach(function (query) {
    return flattenedQueries.push.apply(flattenedQueries, _toConsumableArray(
    require('flattenSplitRelayQueries')(
    require('splitDeferredRelayQueries')(query))));});



  return flattenedQueries;}


function runQueries(
storeData, 
queries, 
callback, 
fetchMode, 
profiler) 
{
  var readyState = { 
    aborted: false, 
    done: false, 
    error: null, 
    ready: false, 
    stale: false };

  var scheduled = false;
  function setReadyState(partial) {
    if (readyState.aborted) {
      return;}

    if (readyState.done || readyState.error) {
      require('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/fbjs/lib/warning')(
      partial.aborted, 
      'GraphQLQueryRunner: Unexpected ready state change.');

      return;}

    readyState = { 
      aborted: partial.aborted != null ? partial.aborted : readyState.aborted, 
      done: partial.done != null ? partial.done : readyState.done, 
      error: partial.error != null ? partial.error : readyState.error, 
      ready: partial.ready != null ? partial.ready : readyState.ready, 
      stale: partial.stale != null ? partial.stale : readyState.stale };

    if (scheduled) {
      return;}

    scheduled = true;
    require('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/fbjs/lib/resolveImmediate')(function () {
      scheduled = false;
      callback(readyState);});}



  var remainingFetchMap = {};
  var remainingRequiredFetchMap = {};

  function onResolved(pendingFetch) {
    var pendingQuery = pendingFetch.getQuery();
    var pendingQueryID = pendingQuery.getID();
    delete remainingFetchMap[pendingQueryID];
    if (!pendingQuery.isDeferred()) {
      delete remainingRequiredFetchMap[pendingQueryID];}


    if (hasItems(remainingRequiredFetchMap)) {
      return;}


    if (require('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/fbjs/lib/someObject')(remainingFetchMap, function (query) {return query.isResolvable();})) {
      // The other resolvable query will resolve imminently and call
      // `setReadyState` instead.
      return;}


    if (hasItems(remainingFetchMap)) {
      setReadyState({ done: false, ready: true, stale: false });} else 
    {
      setReadyState({ done: true, ready: true, stale: false });}}



  function onRejected(pendingFetch, error) {
    setReadyState({ error: error });

    var pendingQuery = pendingFetch.getQuery();
    var pendingQueryID = pendingQuery.getID();
    delete remainingFetchMap[pendingQueryID];
    if (!pendingQuery.isDeferred()) {
      delete remainingRequiredFetchMap[pendingQueryID];}}



  function canResolve(fetch) {
    return require('checkRelayQueryData')(
    storeData.getQueuedStore(), 
    fetch.getQuery());}



  require('RelayTaskScheduler').enqueue(function () {
    var forceIndex = fetchMode === require('RelayFetchMode').REFETCH ? 
    require('generateForceIndex')() : null;

    splitAndFlattenQueries(queries).forEach(function (query) {
      var pendingFetch = storeData.getPendingQueryTracker().add(
      { query: query, fetchMode: fetchMode, forceIndex: forceIndex, storeData: storeData });

      var queryID = query.getID();
      remainingFetchMap[queryID] = pendingFetch;
      if (!query.isDeferred()) {
        remainingRequiredFetchMap[queryID] = pendingFetch;}

      pendingFetch.getResolvedPromise().then(
      onResolved.bind(null, pendingFetch), 
      onRejected.bind(null, pendingFetch));});



    if (!hasItems(remainingFetchMap)) {
      setReadyState({ done: true, ready: true });} else 
    {
      if (!hasItems(remainingRequiredFetchMap)) {
        setReadyState({ ready: true });} else 
      {
        setReadyState({ ready: false });
        require('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/fbjs/lib/resolveImmediate')(function () {
          if (storeData.hasCacheManager()) {
            var requiredQueryMap = require('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/fbjs/lib/mapObject')(
            remainingRequiredFetchMap, 
            function (value) {return value.getQuery();});

            storeData.readFromDiskCache(requiredQueryMap, { 
              onSuccess: function () {
                if (hasItems(remainingRequiredFetchMap)) {
                  setReadyState({ ready: true, stale: true });}} });} else 



          {
            if (require('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/fbjs/lib/everyObject')(remainingRequiredFetchMap, canResolve)) {
              if (hasItems(remainingRequiredFetchMap)) {
                setReadyState({ ready: true, stale: true });}}}});}}






    // Stop profiling when queries have been sent to the network layer.
    profiler.stop();}).
  done();

  return { 
    abort: function () {
      setReadyState({ aborted: true });} };}




module.exports = GraphQLQueryRunner;